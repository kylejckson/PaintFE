//! Build script: scans `assets/brushes/` at compile time and generates
//! a Rust source file that embeds every PNG via `include_bytes!()`.
//!
//! Drop PNGs into `assets/brushes/<category>/` and rebuild — the binary
//! will contain them with no external folder needed at runtime.

use std::fs;
use std::io::Write;
use std::path::Path;

fn title_case(s: &str) -> String {
    s.split(['_', '-'])
        .filter(|w| !w.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => {
                    let mut s = c.to_uppercase().to_string();
                    s.extend(chars);
                    s
                }
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn main() {
    // -- Windows EXE icon embedding -----------------------------------------
    // Embed assets/icons/app_icon.ico into the EXE so Windows shows it in
    // Explorer, the taskbar, and the Alt-Tab switcher.
    #[cfg(target_os = "windows")]
    {
        println!("cargo:rerun-if-changed=assets/icons/app_icon.ico");
        let mut res = winresource::WindowsResource::new();
        res.set_icon("assets/icons/app_icon.ico");
        if let Err(e) = res.compile() {
            eprintln!("winresource: {e} (icon embedding skipped)");
        }
    }

    let brushes_dir = Path::new("assets/brushes");

    // Tell Cargo to rerun if any file under assets/brushes/ changes
    println!("cargo:rerun-if-changed=assets/brushes");

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("brush_tips_embedded.rs");
    let mut f = fs::File::create(&dest).unwrap();

    // If the brushes directory doesn't exist, generate an empty array
    if !brushes_dir.is_dir() {
        writeln!(f, "// Auto-generated: no assets/brushes/ directory found.").unwrap();
        writeln!(f, "&[]").unwrap();
        return;
    }

    // Collect categories (sorted subdirectories)
    let mut categories: Vec<_> = fs::read_dir(brushes_dir)
        .unwrap()
        .filter_map(|e| e.ok())
        .map(|e| e.path())
        .filter(|p| p.is_dir())
        .collect();
    categories.sort();

    // include_bytes! paths are relative to the generated file in OUT_DIR,
    // so we need absolute paths via CARGO_MANIFEST_DIR.
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let manifest_dir = manifest_dir.replace('\\', "/");

    writeln!(f, "// Auto-generated by build.rs — do not edit.").unwrap();
    writeln!(f, "// Each entry is (display_name, category, png_bytes).").unwrap();
    writeln!(f, "&[").unwrap();

    for cat_dir in &categories {
        let cat_name = cat_dir
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("Unknown");
        let cat_display = title_case(cat_name);

        let mut pngs: Vec<_> = fs::read_dir(cat_dir)
            .unwrap()
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| {
                p.extension()
                    .and_then(|ext| ext.to_str())
                    .is_some_and(|ext| ext.eq_ignore_ascii_case("png"))
            })
            .collect();
        pngs.sort();

        for png_path in &pngs {
            let stem = png_path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown");
            let display_name = title_case(stem);

            // Absolute path with forward slashes for include_bytes!
            let abs_path = format!(
                "{}/{}",
                manifest_dir,
                png_path.to_str().unwrap().replace('\\', "/")
            );

            writeln!(
                f,
                "    (\"{}\", \"{}\", include_bytes!(r\"{}\")),",
                display_name, cat_display, abs_path,
            )
            .unwrap();
        }
    }

    writeln!(f, "]").unwrap();
}
